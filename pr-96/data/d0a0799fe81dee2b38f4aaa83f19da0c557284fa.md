# Page snapshot

```yaml
- generic [active] [ref=e1]:
  - generic [ref=e3]:
    - banner [ref=e4]:
      - heading "水無瀬のプログラミング日記" [level=1] [ref=e5]:
        - link "水無瀬のプログラミング日記" [ref=e6] [cursor=pointer]:
          - /url: /
      - navigation "グローバルメニュー" [ref=e7]:
        - button "メニューを開く" [ref=e8]: メニュー
    - main [ref=e10]:
      - article [ref=e11]:
        - generic [ref=e12]:
          - heading "ReactHooksざっくりまとめ" [level=1] [ref=e13]
          - list [ref=e14]:
            - listitem [ref=e15]:
              - link "React" [ref=e16] [cursor=pointer]:
                - /url: /tags/React
          - time [ref=e17]: 2020/05/20
        - generic [ref=e18]:
          - heading "はじめに" [level=1] [ref=e19]
          - paragraph [ref=e20]:
            - text: Hooksを触り始めている今日この頃。
            - text: 雰囲気で色々触っていたけど、だんだん辛くなってきたのでちゃんとまとめていこうと思う。
            - link "APIリファレンス" [ref=e21] [cursor=pointer]:
              - /url: https://ja.reactjs.org/docs/hooks-reference.html
            - text: を見ながら、簡単に使い方とサンプルをまとめておく。
          - heading "TL;DR." [level=1] [ref=e22]
          - paragraph [ref=e23]:
            - link "コード" [ref=e24] [cursor=pointer]:
              - /url: https://github.com/Tetsuya-Minase/program-samples/tree/master/hooks-sample
          - heading "useState" [level=1] [ref=e25]
          - paragraph [ref=e26]:
            - text: component内で使うステートフルな値と、それを更新するための関数を返す。
            - text: Class Componentのstateと同じ。
          - heading "使い方" [level=2] [ref=e27]
          - figure [ref=e28]:
            - code [ref=e30]:
              - generic [ref=e31]: "import {useState} from 'react';"
              - generic [ref=e33]: // useStateに渡した値がstateの初期値になる
              - generic [ref=e34]: const [state, setState] = useState(initialState);
              - generic [ref=e35]: // stateの値を更新したいときはsetStateを使う
              - generic [ref=e36]: setState(updateState);
              - generic [ref=e37]: // 型指定したい場合、useStateの際に指定できる
              - generic [ref=e38]: const [stringState, setStringState] = useState<string>(initialState);
              - generic [ref=e39]: // 初期化を遅延させることもできる
              - generic [ref=e40]: "const [lagyState, setLagyState] = useState(() => {"
              - generic [ref=e41]: // 初期値をなにかしら受け取る
              - generic [ref=e42]: const initialState = getHoge();
              - generic [ref=e43]: return initialState;
              - generic [ref=e44]: "});"
          - heading "サンプル" [level=2] [ref=e45]
          - figure [ref=e46]:
            - code [ref=e48]:
              - generic [ref=e49]: "import React, {useState} from 'react';"
              - generic [ref=e51]: "export const StateComponent: React.FC<any> = () => {"
              - generic [ref=e52]: // useStateを使う
              - generic [ref=e53]: const [greetingMessage, setGreetingMessage] = useState<string>('hello');
              - generic [ref=e54]: return (
              - generic [ref=e55]: <>
              - generic [ref=e56]: "{/* stateの内容を表示 */}"
              - generic [ref=e57]: "<div>{greetingMessage}</div>"
              - generic [ref=e58]: <form>
              - generic [ref=e59]: "{/* stateの内容を更新 */}"
              - generic [ref=e60]: "<input type=\"text\" onChange={text => setGreetingMessage(text.target.value)}/>"
              - generic [ref=e61]: </form>
              - generic [ref=e62]: </>
              - generic [ref=e63]: )
              - generic [ref=e64]: "};"
          - heading "useEffect" [level=1] [ref=e65]
          - paragraph [ref=e66]:
            - text: 副作用を有する可能性のある命令型コードを受け付ける。
            - text: ClassComponentで言うところの
            - code [ref=e68]:
              - text: "`"
              - generic [ref=e69]: componentDidMount
              - text: "`"
            - text: や
            - code [ref=e71]:
              - text: "`"
              - generic [ref=e72]: componentDidUpdate
              - text: "`"
            - text: の置き換え。
            - text: って言われているけど実際には近しい処理くらいが正しい気がする。
            - text: ※
            - code [ref=e74]:
              - text: "`"
              - generic [ref=e75]: componentDidMount
              - text: "`"
            - text: や
            - code [ref=e77]:
              - text: "`"
              - generic [ref=e78]: componentDidUpdate
              - text: "`"
            - text: とは別物の認識。
          - heading "使い方" [level=2] [ref=e79]
          - figure [ref=e80]:
            - code [ref=e82]:
              - generic [ref=e83]: // これだとレンダリングの度に毎回実行される
              - generic [ref=e84]: "useEffect(() => {"
              - generic [ref=e85]: // 副作用がある処理を行う
              - generic [ref=e86]: const subscription = props.source.subscribe();
              - generic [ref=e87]: // クリーンアップ処理を行いたい場合は、useEffectに渡す関数の戻り値に関数を渡せば良い
              - generic [ref=e88]: "return () => {"
              - generic [ref=e89]: subscription.unsubscribe();
              - generic [ref=e90]: "};"
              - generic [ref=e91]: "});"
              - generic [ref=e93]: // 副作用が依存している値を第2配列に指定する
              - generic [ref=e94]: // props.sourceに変更があったときのみ実行する
              - generic [ref=e95]: "useEffect(() => {"
              - generic [ref=e96]: const subscription = props.source.subscribe();
              - generic [ref=e97]: "return () => {"
              - generic [ref=e98]: subscription.unsubscribe();
              - generic [ref=e99]: "};"
              - generic [ref=e100]: "}, [props.source]);"
              - generic [ref=e102]: // 一度だけ実行したい場合△
              - generic [ref=e103]: "useEffect(() => {"
              - generic [ref=e104]: const subscription = props.source.subscribe();
              - generic [ref=e105]: "return () => {"
              - generic [ref=e106]: subscription.unsubscribe();
              - generic [ref=e107]: "};"
              - generic [ref=e108]: // 第2引数に空配列を渡してあげれば良い
              - generic [ref=e109]: // 空配列を渡すことで、何にも依存しない(2回目が実行されることない)ことを伝える
              - generic [ref=e110]: // 処理としてはprops.sourceに依存するため、渡して上げるのが良い
              - generic [ref=e111]: "}, []);"
              - generic [ref=e113]: // 一度だけ実行したい場合◎
              - generic [ref=e114]: "useEffect(() => {"
              - generic [ref=e115]: "function doSomething() {"
              - generic [ref=e116]: console.log(someProp);
              - generic [ref=e117]: "}"
              - generic [ref=e119]: doSomething();
              - generic [ref=e120]: "}, [someProp]);"
          - heading "サンプル" [level=2] [ref=e121]
          - figure [ref=e122]:
            - code [ref=e124]:
              - generic [ref=e125]: "export const EffectComponent: React.FC<any> = () => {"
              - generic [ref=e126]: const [count, setCount] = useState(0);
              - generic [ref=e127]: // useEffectを使う
              - generic [ref=e128]: "useEffect(() => {"
              - generic [ref=e129]: const interval = setInterval(() => setCount(count + 1), 1000);
              - generic [ref=e130]: // intervalをリセットする
              - generic [ref=e131]: return () => clearInterval(interval);
              - generic [ref=e132]: // このeffectはcountに依存しているので、countを第二引数に渡す
              - generic [ref=e133]: // →ここを渡さないとeffect無いではstateが初期値から変わらない
              - generic [ref=e134]: "}, [count]);"
              - generic [ref=e135]: "return <div>{count}</div>"
              - generic [ref=e136]: "};"
          - heading "useContext" [level=1] [ref=e137]
          - paragraph [ref=e138]:
            - text: コンテクストオブジェクトを受け取り、そのコンテクストの現在値を返す。
            - text: コンテクストの現在値は、ツリー内でこのフックを呼んだコンポーネントの直近にある
            - code [ref=e140]:
              - text: "`"
              - generic [ref=e141]: <MyContext.Provider>
              - text: "`"
            - text: の value の値によって決定される。
          - paragraph [ref=e142]:
            - text: ざっくり孫コンポーネントなど階層が離れているコンポーネントに値を渡せるようになる認識。
            - text: (バケツリレーをしなくても良くなる)
          - paragraph [ref=e143]:
            - text: いつ使うのが良いかは
            - link "公式ドキュメント" [ref=e144] [cursor=pointer]:
              - /url: https://ja.reactjs.org/docs/context.html#when-to-use-context
            - text: を読むのが良さそう。
          - heading "使い方" [level=2] [ref=e145]
          - figure [ref=e146]:
            - code [ref=e148]:
              - generic [ref=e149]: "const themes = {"
              - generic [ref=e150]: "light: {"
              - generic [ref=e151]: "foreground: \"#000000\","
              - generic [ref=e152]: "background: \"#eeeeee\""
              - generic [ref=e153]: "},"
              - generic [ref=e154]: "dark: {"
              - generic [ref=e155]: "foreground: \"#ffffff\","
              - generic [ref=e156]: "background: \"#222222\""
              - generic [ref=e157]: "}"
              - generic [ref=e158]: "};"
              - generic [ref=e160]: const ThemeContext = React.createContext(themes.light);
              - generic [ref=e161]: // 型を指定したければ下記のようにする
              - generic [ref=e162]: "type ThemeColor = {"
              - generic [ref=e163]: "foreground: string;"
              - generic [ref=e164]: "background: string;"
              - generic [ref=e165]: "}"
              - generic [ref=e166]: const ThemeContext = React.createContext<ThemeColor>(themes.light);
              - generic [ref=e168]: export const App = () => (
              - generic [ref=e169]: // ここでcontextの現在値がdarkになる
              - generic [ref=e170]: "<ThemeContext.Provider value={themes.dark}>"
              - generic [ref=e171]: <Toolbar/>
              - generic [ref=e172]: </ThemeContext.Provider>
              - generic [ref=e173]: );
              - generic [ref=e174]: export const AppInitial = () => (
              - generic [ref=e175]: // 何も渡さなければ初期値(themes.light)になる
              - generic [ref=e176]: <Toolbar/>
              - generic [ref=e177]: );
              - generic [ref=e179]: const Toolbar = props => (
              - generic [ref=e180]: <div>
              - generic [ref=e181]: <ThemedButton/>
              - generic [ref=e182]: </div>
              - generic [ref=e183]: );
              - generic [ref=e185]: "const ThemedButton = () => {"
              - generic [ref=e186]: const theme = useContext(ThemeContext);
              - generic [ref=e187]: return (
              - generic [ref=e188]: "<button style={{background: theme.background, color: theme.foreground}}>"
              - generic [ref=e189]: I am styled by theme context!
              - generic [ref=e190]: </button>
              - generic [ref=e191]: );
              - generic [ref=e192]: "}"
          - heading "サンプル" [level=2] [ref=e193]
          - figure [ref=e194]:
            - code [ref=e196]:
              - generic [ref=e197]: "import React, {useContext} from 'react';"
              - generic [ref=e199]: // Contextを作成
              - generic [ref=e200]: const MemoContext = React.createContext<string>('initial text.');
              - generic [ref=e202]: export const ContextComponent = () => (
              - generic [ref=e203]: // textの内容を変える
              - generic [ref=e204]: <MemoContext.Provider value="memo text.">
              - generic [ref=e205]: <MemoArea/>
              - generic [ref=e206]: </MemoContext.Provider>
              - generic [ref=e207]: );
              - generic [ref=e209]: const MemoArea = () => (
              - generic [ref=e210]: <div>
              - generic [ref=e211]: <Text/>
              - generic [ref=e212]: </div>
              - generic [ref=e213]: );
              - generic [ref=e215]: "const Text = () => {"
              - generic [ref=e216]: const theme = useContext(MemoContext);
              - generic [ref=e217]: return (
              - generic [ref=e218]: "<span>{theme}</span>"
              - generic [ref=e219]: );
              - generic [ref=e220]: "}"
          - heading "useReducer" [level=1] [ref=e221]
          - paragraph [ref=e222]:
            - code [ref=e224]:
              - text: "`"
              - generic [ref=e225]: useState
              - text: "`"
            - text: の親戚。Reduxのreducerを記述できる。
            - code [ref=e227]:
              - text: "`"
              - generic [ref=e228]: (state, action) => newState
              - text: "`"
            - text: という型のreducer を受け取り、現在の
            - code [ref=e230]:
              - text: "`"
              - generic [ref=e231]: state
              - text: "`"
            - text: を
            - code [ref=e233]:
              - text: "`"
              - generic [ref=e234]: dispatch
              - text: "`"
            - text: メソッドとペアにして返す。
          - heading "使い方" [level=2] [ref=e235]
          - figure [ref=e236]:
            - code [ref=e238]:
              - generic [ref=e239]: // initialState
              - generic [ref=e240]: "const intialState = {count: 0}"
              - generic [ref=e241]: // Reducerを作成(stateとactionを受け取る関数)
              - generic [ref=e242]: "const reducer = (state, action) => {"
              - generic [ref=e243]: "switch (action.type) {"
              - generic [ref=e244]: "case 'increment':"
              - generic [ref=e245]: "return {count: state.count + 1};"
              - generic [ref=e246]: "case 'decrement':"
              - generic [ref=e247]: "return {count: state.count - 1};"
              - generic [ref=e248]: "default:"
              - generic [ref=e249]: throw new Error();
              - generic [ref=e250]: "}"
              - generic [ref=e251]: "}"
              - generic [ref=e252]: // useRedcerは第一引数にreducer、第二引数にinitialStateを渡してあげる
              - generic [ref=e253]: // stateとdispatchメソッドが返ってくる(どちらもReduxの使い方とほぼ同じ)
              - generic [ref=e254]: const [state, dispatch] = useReducer(reducer, initialState);
              - generic [ref=e256]: // 初期化を遅延させたい場合や特定の場合に初期値にさせたい場合、
              - generic [ref=e257]: // 第三引数に初期化関数を渡してあげる
              - generic [ref=e258]: const init
              - generic [ref=e259]: "(initialCount) => ({count: initialCount});"
              - generic [ref=e260]: "const reducer = (state, action) => {"
              - generic [ref=e261]: "switch (action.type) {"
              - generic [ref=e262]: "case 'increment':"
              - generic [ref=e263]: "return {count: state.count + 1};"
              - generic [ref=e264]: "case 'decrement':"
              - generic [ref=e265]: "return {count: state.count - 1};"
              - generic [ref=e266]: "case 'reset':"
              - generic [ref=e267]: return init(action.payload);
              - generic [ref=e268]: "default:"
              - generic [ref=e269]: throw new Error();
              - generic [ref=e270]: "}"
              - generic [ref=e271]: "}"
              - generic [ref=e272]: "const Counter = ({initialCount}) => {"
              - generic [ref=e273]: const [state, dispatch] = useReducer(reducer, initialCount, init);
              - generic [ref=e274]: return (
              - generic [ref=e275]: <>
              - generic [ref=e276]: "Count: {state.count}"
              - generic [ref=e277]: <button
              - generic [ref=e278]: "onClick={() => dispatch({type: 'reset', payload: initialCount})}>"
              - generic [ref=e279]: Reset
              - generic [ref=e280]: </button>
              - generic [ref=e281]: </>
              - generic [ref=e282]: );
              - generic [ref=e283]: "}"
          - heading "サンプル" [level=2] [ref=e284]
          - figure [ref=e285]:
            - code [ref=e287]:
              - generic [ref=e288]: "import React, {useReducer} from 'react';"
              - generic [ref=e290]: "type State = { count: number };"
              - generic [ref=e291]: "const initialState: State = {count: 0};"
              - generic [ref=e293]: "const add = (num: number) => ({type: 'ADD', payload: num});"
              - generic [ref=e294]: "const subtract = (num: number) => ({type: 'SUBTRACT', payload: num});"
              - generic [ref=e295]: type Action = ReturnType<typeof add | typeof subtract>;
              - generic [ref=e297]: "const reducer = (state: State, action: Action) => {"
              - generic [ref=e298]: "switch (action.type) {"
              - generic [ref=e299]: "case 'ADD':"
              - generic [ref=e300]: "return {count: state.count + action.payload};"
              - generic [ref=e301]: "case 'SUBTRACT':"
              - generic [ref=e302]: "return {count: state.count - action.payload};"
              - generic [ref=e303]: "default:"
              - generic [ref=e304]: throw new Error();
              - generic [ref=e305]: "}"
              - generic [ref=e306]: "}"
              - generic [ref=e308]: "export const ReducerComponent = () => {"
              - generic [ref=e309]: const [state, dispatch] = useReducer(reducer, initialState);
              - generic [ref=e310]: return (
              - generic [ref=e311]: <>
              - generic [ref=e312]: "Count: {state.count}"
              - generic [ref=e313]: "<button onClick={() => dispatch(subtract(1))}>-</button>"
              - generic [ref=e314]: "<button onClick={() => dispatch(add(1))}>+</button>"
              - generic [ref=e315]: </>
              - generic [ref=e316]: );
              - generic [ref=e317]: "}"
          - heading "useCallback" [level=1] [ref=e318]
          - paragraph [ref=e319]:
            - text: メモ化されたコールバックを返す。
            - text: 第一引数にコールバック関数、第二引数にコールバックが依存している値を配列で渡す。
          - heading "使い方" [level=2] [ref=e320]
          - figure [ref=e321]:
            - code [ref=e323]:
              - generic [ref=e324]: const memoizedCallback = useCallback(
              - generic [ref=e325]: // 第一引数に関数を指定
              - generic [ref=e326]: () => doSomething(a, b),
              - generic [ref=e327]: // 第一引数に渡した関数が依存している値(a, b)をリストで渡してあげる
              - generic [ref=e328]: "[a, b],"
              - generic [ref=e329]: );
          - heading "サンプル" [level=2] [ref=e330]
          - figure [ref=e331]:
            - code [ref=e333]:
              - generic [ref=e334]: "import React, {useCallback, useState} from 'react';"
              - generic [ref=e336]: "export const CallbackComponent = () => {"
              - generic [ref=e337]: const [count, setCount] = useState(0);
              - generic [ref=e338]: // コールバックはcountに依存しているので、第二引数にcountを渡してあげる
              - generic [ref=e339]: // 渡さないと関数内のcountの値が更新されない
              - generic [ref=e340]: const buttonClick = useCallback(() => setCount(count + 1), [count]);
              - generic [ref=e341]: "return <ButtonComponent count={count} buttonClick={buttonClick}/>"
              - generic [ref=e342]: "}"
              - generic [ref=e343]: "const ButtonComponent = ({count, buttonClick}: { count: number, buttonClick: () => void }) => ("
              - generic [ref=e344]: <div>
              - generic [ref=e345]: "count: {count}"
              - generic [ref=e346]: "<button onClick={buttonClick}>click</button>"
              - generic [ref=e347]: </div>
              - generic [ref=e348]: )
          - heading "useMemo" [level=1] [ref=e349]
          - paragraph [ref=e350]:
            - text: メモ化された値を返す。
            - text: 関数の結果を保持することができるので、同じ引数で関数を呼び出した時には中身の処理は実行せず結果だけ返す。
            - text: これによりレンダリングの度に重い処理が走らなくて済むようになる。
          - heading "使い方" [level=2] [ref=e351]
          - figure [ref=e352]:
            - code [ref=e354]:
              - generic [ref=e355]: const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
          - heading "サンプル" [level=2] [ref=e356]
          - paragraph [ref=e357]: あまり良い例を思いつかなかった。
          - figure [ref=e358]:
            - code [ref=e360]:
              - generic [ref=e361]: "import React, {useMemo} from 'react';"
              - generic [ref=e363]: "export const MemoComponent = () => {"
              - generic [ref=e364]: const count = 10000;
              - generic [ref=e365]: // 10000回足し算行う
              - generic [ref=e366]: const memoValue = useMemo(() => [...Array(count)].reduce((pure) => pure + 1, 0), [count]);
              - generic [ref=e367]: "return <div>{memoValue}</div>"
              - generic [ref=e368]: "}"
          - heading "useRef" [level=1] [ref=e369]
          - paragraph [ref=e370]:
            - code [ref=e372]:
              - text: "`"
              - generic [ref=e373]: .current
              - text: "`"
            - text: プロパティが
            - code [ref=e375]:
              - text: "`"
              - generic [ref=e376]: useRef
              - text: "`"
            - text: を呼び出した渡す値で初期化されたミュータブルなオブジェクトを返す。
            - text: 返されるオブジェクトはコンポーネントが存在する限り、存在し続ける。
          - paragraph [ref=e377]:
            - text: 多分よく使われるのは、DOMにアクセスする場合に
            - code [ref=e379]:
              - text: "`"
              - generic [ref=e380]: "ref={hogeRef}"
              - text: "`"
            - text: みたいな使い方だと思う。
            - code [ref=e382]:
              - text: "`"
              - generic [ref=e383]: useRef
              - text: "`"
            - text: はref属性を扱うだけではなく、あらゆる書き換え可能な値を保持して多くためにも使える。
          - heading "使い方" [level=2] [ref=e384]
          - figure [ref=e385]:
            - code [ref=e387]:
              - generic [ref=e388]: const refContainer = useRef(initialValue);
          - heading "サンプル" [level=1] [ref=e389]
          - figure [ref=e390]:
            - code [ref=e392]:
              - generic [ref=e393]: "import React, {useRef, RefObject} from 'react';"
              - generic [ref=e395]: "export const RefComponent: React.FC = () => {"
              - generic [ref=e396]: // Dom触るためのrefを作成
              - generic [ref=e397]: "const useRefWithDom: RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null);"
              - generic [ref=e398]: // 値を保持しておくrefを作成
              - generic [ref=e399]: const useRefWithValue = useRef('initial value');
              - generic [ref=e400]: return (
              - generic [ref=e401]: <div>
              - generic [ref=e402]: "<input type=\"text\" ref={useRefWithDom}/>"
              - generic [ref=e403]: "<button onClick={() => {"
              - generic [ref=e404]: "if (!useRefWithDom.current) {"
              - generic [ref=e405]: return;
              - generic [ref=e406]: "}"
              - generic [ref=e407]: // 変更前('initial value')
              - generic [ref=e408]: "console.log('useRefWithValue.current: ', useRefWithValue.current);"
              - generic [ref=e409]: // currentを上書きすることで変更できる
              - generic [ref=e410]: useRefWithValue.current = useRefWithDom.current.value;
              - generic [ref=e411]: // 変更後('hoge')
              - generic [ref=e412]: "console.log('useRefWithValue.current: ', useRefWithValue.current);"
              - generic [ref=e414]: "}}>ボタン"
              - generic [ref=e415]: </button>
              - generic [ref=e416]: </div>
              - generic [ref=e417]: );
              - generic [ref=e418]: "};"
          - heading "useImperativeHandle" [level=1] [ref=e419]
          - paragraph [ref=e420]:
            - code [ref=e422]:
              - text: "`"
              - generic [ref=e423]: ref
              - text: "`"
            - text: が使われた時に親コンポーネントに渡されるインスタンス値をカスタマイズするのに使う。
            - text: 使う時には
            - code [ref=e425]:
              - text: "`"
              - generic [ref=e426]: "[forwardRef](https://ja.reactjs.org/docs/react-api.html#reactforwardref)"
              - text: "`"
            - text: と一緒に使う。
          - heading "使い方" [level=2] [ref=e427]
          - figure [ref=e428]:
            - code [ref=e430]:
              - generic [ref=e431]: "function FancyInput(props, ref) {"
              - generic [ref=e432]: const inputRef = useRef();
              - generic [ref=e433]: "useImperativeHandle(ref, () => ({"
              - generic [ref=e434]: "focus: () => {"
              - generic [ref=e435]: inputRef.current.focus();
              - generic [ref=e436]: "}"
              - generic [ref=e437]: "}));"
              - generic [ref=e438]: "return <input ref={inputRef} ..."
              - generic [ref=e439]: />;
              - generic [ref=e440]: "}"
              - generic [ref=e442]: FancyInput = forwardRef(FancyInput);
          - heading "サンプル" [level=2] [ref=e443]
          - figure [ref=e444]:
            - code [ref=e446]:
              - generic [ref=e447]: "import React, {forwardRef, useRef, useImperativeHandle, RefObject} from 'react';"
              - generic [ref=e449]: "const FancyInput = (props: any, ref: any) => {"
              - generic [ref=e450]: // refを定義
              - generic [ref=e451]: "const inputRef: RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null);"
              - generic [ref=e452]: // 受け取ったrefにfocus関数を追加する
              - generic [ref=e453]: "useImperativeHandle(ref, () => ({"
              - generic [ref=e454]: "focus: () => inputRef?.current?.focus()"
              - generic [ref=e456]: "}));"
              - generic [ref=e457]: "return <input ref={inputRef}/>;"
              - generic [ref=e458]: "}"
              - generic [ref=e459]: // forwardRefに作った関数を渡す(変数に置かなくても問題なし)
              - generic [ref=e460]: const FancyInputRef = forwardRef(FancyInput);
              - generic [ref=e462]: "export const ImperativeHandleComponent: React.FC = () => {"
              - generic [ref=e463]: // ここで使うrefを定義
              - generic [ref=e464]: "const ref: RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null);"
              - generic [ref=e465]: return (<>
              - generic [ref=e466]: "{/* refを渡す(このrefにfocus関数が追加される) */}"
              - generic [ref=e467]: "<FancyInputRef ref={ref}/>"
              - generic [ref=e468]: "{/* クリックした時にテキストボックスにフォーカスする */}"
              - generic [ref=e469]: "<button onClick={() => ref?.current?.focus()}>clickでフォーカス</button>"
              - generic [ref=e470]: </>)
              - generic [ref=e472]: "};"
          - heading "useLayoutEffect" [level=1] [ref=e473]
          - paragraph [ref=e474]:
            - text: 基本的には
            - code [ref=e476]:
              - text: "`"
              - generic [ref=e477]: useEffect
              - text: "`"
            - text: と同じ。
            - text: 違う点はDOM の変更があった後で同期的に副作用が呼び出されるところ。
            - text: DOMを操作して再描画する場合に使う。
            - text: 最初は
            - code [ref=e479]:
              - text: "`"
              - generic [ref=e480]: useEffect
              - text: "`"
            - text: を使って、問題があるときのみ
            - code [ref=e482]:
              - text: "`"
              - generic [ref=e483]: useLayoutEffect
              - text: "`"
            - text: を使う方が良い。
          - paragraph [ref=e484]:
            - text: と、
            - link "公式サイトに書いてある" [ref=e485] [cursor=pointer]:
              - /url: https://ja.reactjs.org/docs/hooks-reference.html#uselayouteffect
            - text: 。
          - heading "useDebugValue" [level=1] [ref=e486]
          - paragraph [ref=e487]: React DevTools でカスタムフックのラベルを表示することができる。
          - heading "使い方" [level=2] [ref=e488]
          - figure [ref=e489]:
            - code [ref=e491]:
              - generic [ref=e492]: useDebugValue(value)
          - heading "サンプル" [level=2] [ref=e493]
          - figure [ref=e494]:
            - code [ref=e496]:
              - generic [ref=e497]: "const useFriendStatus = (friendID) => {"
              - generic [ref=e498]: const [isOnline, setIsOnline] = useState(null);
              - generic [ref=e500]: // ...
              - generic [ref=e502]: // DevToolのラベルが下記のように表示される
              - generic [ref=e503]: "// \"FriendStatus: Online\""
              - generic [ref=e504]: "useDebugValue(isOnline ? 'Online' : 'Offline');"
              - generic [ref=e506]: return isOnline;
              - generic [ref=e507]: "}"
          - heading "まとめ" [level=1] [ref=e508]
          - paragraph [ref=e509]:
            - text: Hooksについてざっくりまとめた。
            - code [ref=e511]:
              - text: "`"
              - generic [ref=e512]: useState
              - text: "`"
            - text: とか
            - code [ref=e514]:
              - text: "`"
              - generic [ref=e515]: useEffect
              - text: "`"
            - text: とか基本的なHooksについてはだいぶわかりやすいと思った。
            - text: メモ化ができる
            - code [ref=e517]:
              - text: "`"
              - generic [ref=e518]: useMemo
              - text: "`"
            - text: と
            - code [ref=e520]:
              - text: "`"
              - generic [ref=e521]: useCallback
              - text: "`"
            - text: については常に使えば良いってわけじゃなさそうなので、使っていくうちに使い所を見極めたい。
          - heading "参考サイト" [level=1] [ref=e522]
          - list [ref=e523]:
            - listitem [ref=e524]:
              - link "フック API リファレンス – React" [ref=e525] [cursor=pointer]:
                - /url: https://ja.reactjs.org/docs/hooks-reference.html
            - listitem [ref=e526]:
              - link "React の最上位 API – React" [ref=e527] [cursor=pointer]:
                - /url: https://ja.reactjs.org/docs/react-api.html#reactforwardref
        - generic [ref=e528]:
          - link "Xに投稿する" [ref=e530] [cursor=pointer]:
            - /url: https://twitter.com/intent/tweet?text=ReactHooks%E3%81%96%E3%81%A3%E3%81%8F%E3%82%8A%E3%81%BE%E3%81%A8%E3%82%81%0A%23%E6%B0%B4%E7%84%A1%E7%80%AC%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E6%97%A5%E8%A8%98&url=https%3A%2F%2Ftminasen.dev%2Fblog%2F20200520
            - img "Xに投稿する" [ref=e532]
          - link "Githubリンク" [ref=e534] [cursor=pointer]:
            - /url: https://github.com/Tetsuya-Minase/tminasen.dev/tree/master/src/pages/blog/20200520.mdx
            - img "Githubリンク" [ref=e536]
    - contentinfo [ref=e537]:
      - generic [ref=e538]: ©2026 tminasen
      - generic [ref=e539]: This site uses Google Analytics.
  - alert [ref=e540]
```